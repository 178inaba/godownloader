package main

import (
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"path"
	"strings"
	"text/template"

	"github.com/goreleaser/goreleaser/config"
	yaml "gopkg.in/yaml.v1"
)

var tplsrc = `#!/bin/sh
set -e
#  Code generated by godownloader. DO NOT EDIT.

BINARY={{ .Build.Binary }}
FORMAT={{ .Archive.Format }}
OWNER={{ $.Release.GitHub.Owner }}
REPO={{ $.Release.GitHub.Name }}
BINDIR=${BINDIR:-./bin}

VERSION=$1
if [ -z "${VERSION}" ]; then
echo ""
echo "$0: download go binaries for ${OWNER}/${REPO}"
echo ""
echo "Usage: $0 [version]"
echo "  where [version] is 'latest' or a version number from"
echo "  https://github.com/${OWNER}/${REPO}/releases"
echo ""
echo "Generated by godownloader"
echo " https://github.com/goreleaser/godownloader"
echo ""
exit 1
fi

# download dest source
# if dest is "-", then output to stdout
# if source is api.github.com add auth token
download() {
  DEST=$1
  SOURCE=$2

  HEADER=""
  case $SOURCE in 
  https://api.github.com*)
     test -z "$GITHUB_TOKEN" || HEADER="Authorization: token $GITHUB_TOKEN"
     ;;
  esac

  if which curl > /dev/null; then
    WGET="curl -sSL"
    test -z "$GITHUB_TOKEN" || WGET="${WGET} -H \"${HEADER}\""
    if [ "${DEST}" != "-" ]; then
      WGET="$WGET -o $DEST"
    fi
  elif which wget > /dev/null; then
    WGET="wget -q -O $DEST"
    test -z "$GITHUB_TOKEN" || WGET="${WGET} --header \"${HEADER}\""
  else
    echo "Unable to find wget or curl.  Exit"
    exit 1
  fi

  ${WGET} ${SOURCE}
}

if [ "${VERSION}" = "latest" ]; then
  echo "Checking GitHub for latest version of ${OWNER}/${REPO}"
  VERSION=$(download - https://api.github.com/repos/${OWNER}/${REPO}/releases/latest | grep -m 1 "\"name\":" | cut -d ":" -f 2 | tr -d ' ",')
  if [ -z "${VERSION}" ]; then
    echo "Unable to determine latest release for ${OWNER}/${REPO}"
    exit 1
   fi
fi

# if version starts with 'v', remove it
VERSION=${VERSION#v}

OS=$(uname -s)
ARCH=$(uname -m)

# change format (tar.gz or zip) based on ARCH
{{- with .Archive.FormatOverrides }}
case ${ARCH} in
{{- range . }}
{{ .Goos }}) FORMAT={{ .Format }} ;;
esac
{{- end }}
{{- end }}

# adjust archive name based on OS
{{- with .Archive.Replacements }}
case ${OS} in 
{{- range $k, $v := . }}
{{ $k }}) OS={{ $v }} ;;
{{- end }}
esac

# adjust archive name based on ARCH
case ${ARCH} in
{{- range $k, $v := . }}
{{ $k }}) ARCH={{ $v }} ;;
{{- end }}
esac
{{- end }}

{{ .Archive.NameTemplate }}
TARBALL=${NAME}.${FORMAT}
URL=https://github.com/${OWNER}/${REPO}/releases/download/v${VERSION}/${TARBALL}

# Destructive operations start here
#
#
test -z "$TMPDIR" && TMPDIR="$(mktemp -d)"
mkdir -p ${TMPDIR}
rm -f ${TMPDIR}/${TARBALL}
download ${TMPDIR}/${TARBALL} ${URL}
case ${FORMAT} in
  tar.gz)
   tar -C ${TMPDIR} -xzf ${TMPDIR}/${TARBALL}
   ;;
  zip)
   (cd ${TMPDIR} && unzip ${TARBALL})
   ;;
  *)
   echo "unknown format '${FORMAT}' - exiting"
   exit 1
   ;;
esac
install -d ${BINDIR}
install ${TMPDIR}/${BINARY} ${BINDIR}/
`

func makeShell(cfg *config.Project) (string, error) {
	var out bytes.Buffer
	t, err := template.New("shell").Parse(tplsrc)
	if err != nil {
		return "", err
	}
	err = t.Execute(&out, cfg)
	return out.String(), err
}

// converts the given name template to it's equivalent in shell
// except for the default goreleaser templates, templates with
// conditionals will return an error
//
// {{ .Binary }} --->  NAME=${BINARY}, etc.
//
func makeName(target string) (string, error) {
	prefix := ""
	// TODO: error on conditionals
	if target == "" || target == "{{ .Binary }}_{{ .Os }}_{{ .Arch }}{{ if .Arm }}v{{ .Arm }}{{ end }}" {
		prefix = "if [ ! -z \"${ARM}\" ]; then ARM=\"v$ARM\"; fi"
		target = "{{ .Binary }}_{{ .Os }}_{{ .Arch }}{{ .Arm }}"
	}
	var varmap = map[string]string{
		"Os":      "${OS}",
		"Arch":    "${ARCH}",
		"Arm":     "${ARM}",
		"Version": "${VERSION}",
		"Tag":     "${TAG}",
		"Binary":  "${BINARY}",
	}

	var out bytes.Buffer
	if prefix != "" {
		out.WriteString(prefix + "\n")
	}
	out.WriteString("NAME=")
	t, err := template.New("name").Parse(target)
	if err != nil {
		return "", err
	}
	err = t.Execute(&out, varmap)
	return out.String(), err
}

func readURL(loc string) ([]byte, error) {
	resp, err := http.Get(loc)
	if err != nil {
		return nil, err
	}
	body, err := ioutil.ReadAll(resp.Body)

	// to make errcheck be happy
	errc := resp.Body.Close()
	if err != nil {
		return nil, err
	}
	if errc != nil {
		return nil, errc
	}
	return body, err
}

func Load(repo string, file string) (*config.Project, error) {
	if repo == "" && file == "" {
		return nil, fmt.Errorf("Need a repo or file")
	}
	if file == "" {
		file = "https://raw.githubusercontent.com/" + repo + "/master/goreleaser.yml"
	}
	var body []byte
	var err error
	log.Printf("Reading %s", file)
	if strings.HasPrefix(file, "http") {
		body, err = readURL(file)
	} else {
		body, err = ioutil.ReadFile(file)
	}
	if err != nil {
		return nil, err
	}
	project := &config.Project{}
	err = yaml.Unmarshal(body, project)
	if err != nil {
		return nil, err
	}

	// if not specified add in GitHub owner/repo info
	if project.Release.GitHub.Owner == "" {
		if repo == "" {
			return nil, fmt.Errorf("Need to provide owner/name repo!")
		}
		project.Release.GitHub.Owner = path.Dir(repo)
		project.Release.GitHub.Name = path.Base(repo)
	}

	// set default archive format
	if project.Archive.Format == "" {
		project.Archive.Format = "tar.gz"
	}

	// set default binary name
	if project.Build.Binary == "" {
		project.Build.Binary = path.Base(repo)
	}

	// Convert replacements from GOOS/GOARCH to uname.

	// map of golang OS/ARCH identifier to what uname uses
	uname := map[string]string{
		"darwin":  "Darwin",
		"linux":   "Linux",
		"freebsd": "FreeBSD",
		"openbsd": "OpenBSD",
		"netbsd":  "NetBSD",
		"windows": "Windows",
		"386":     "i386",
		"amd64":   "x86_64",
	}
	rmap := make(map[string]string)
	for k, v := range project.Archive.Replacements {
		newk := uname[k]

		// if unknown, keep
		if newk == "" {
			rmap[k] = v
			continue
		}

		// if mapping is an idenity, then ignore
		if newk == v {
			continue
		}

		rmap[newk] = v
	}
	project.Archive.Replacements = rmap

	// do something similar for format over-rides
	for i := 0; i < len(project.Archive.FormatOverrides); i++ {
		goos := project.Archive.FormatOverrides[i].Goos
		newos := uname[goos]
		if newos != "" {
			project.Archive.FormatOverrides[i].Goos = newos
		}
	}
	return project, nil
}

func main() {
	repo := flag.String("repo", "", "owner/name of repository")
	flag.Parse()
	args := flag.Args()
	file := ""
	if len(args) > 0 {
		file = args[0]
	}
	cfg, err := Load(*repo, file)
	if err != nil {
		log.Fatalf("Unable to parse: %s", err)
	}

	// get name template
	name, err := makeName(cfg.Archive.NameTemplate)
	cfg.Archive.NameTemplate = name
	if err != nil {
		log.Fatalf("Unable generate name: %s", err)
	}

	shell, err := makeShell(cfg)
	if err != nil {
		log.Fatalf("Unable to generate shell: %s", err)
	}
	fmt.Println(shell)
}
